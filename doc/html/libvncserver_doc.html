<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LibVNCServer/LibVNCClient: LibVNCServer Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LibVNCServer/LibVNCClient
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">LibVNCServer Documentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="create_server"></a>
Creating a server instance</h1>
<p>To make a server, you just have to initialise a server structure using the function <a class="el" href="group__libvncserver__api.html#ga7bc0e73d60a80ddc855fe1c4313fe57d">rfbGetScreen()</a>, like </p><div class="fragment"><div class="line">rfbScreenInfoPtr screen =</div><div class="line">  <a class="code" href="group__libvncserver__api.html#ga7bc0e73d60a80ddc855fe1c4313fe57d">rfbGetScreen</a>(argc,argv,screenwidth,screenheight,8,3,bpp);</div></div><!-- fragment --><p> where byte per pixel should be 1, 2 or 4. If performance doesn't matter, you may try bpp=3 (internally one cannot use native data types in this case; if you want to use this, look at <a class="el" href="pnmshow24_8c.html">pnmshow24.c</a>).</p>
<p>You then can set hooks and io functions (see <a class="el" href="libvncserver_doc.html#making_it_interactive">Making it interactive</a>) or other options (see <a class="el" href="libvncserver_doc.html#server_options">Optional Server Features</a>).</p>
<p>And you allocate the frame buffer like this: </p><div class="fragment"><div class="line">screen-&gt;frameBuffer = (<span class="keywordtype">char</span>*)malloc(screenwidth*screenheight*bpp);</div></div><!-- fragment --><p> After that, you initialize the server, like </p><div class="fragment"><div class="line"><a class="code" href="group__libvncserver__api.html#ga3adb1ec74d14601d08bb501f12a1735a">rfbInitServer</a>(screen);</div></div><!-- fragment --><p> You can use a blocking event loop, a background (pthread based) event loop, or implement your own using the <a class="el" href="group__libvncserver__api.html#ga94e550459ace749f762f8e891930d55b">rfbProcessEvents()</a> function.</p>
<h2><a class="anchor" id="server_options"></a>
Optional Server Features</h2>
<p>These options have to be set between <a class="el" href="group__libvncserver__api.html#ga7bc0e73d60a80ddc855fe1c4313fe57d">rfbGetScreen()</a> and <a class="el" href="group__libvncserver__api.html#ga3adb1ec74d14601d08bb501f12a1735a">rfbInitServer()</a>.</p>
<p>If you already have a socket to talk to, just set <a class="el" href="structrfb_screen_info.html#a7dbfbecf4c26279ef5175aa6a394d0ae">rfbScreenInfo::inetdSock</a> (originally this is for inetd handling, but why not use it for your purpose?).</p>
<p>To also start an HTTP server (running on port 5800+display_number), you have to set <a class="el" href="structrfb_screen_info.html#a0e5d35dd67c77a92c91ede56b5e0e75c">rfbScreenInfo::httpDir</a> to a directory containing vncviewer.jar and index.vnc (like the included "webclients" directory).</p>
<h1><a class="anchor" id="making_it_interactive"></a>
Making it interactive</h1>
<p>Whenever you draw something, you have to call </p><div class="fragment"><div class="line"><a class="code" href="group__libvncserver__api.html#ga4063480bb7e8d337ea2948638957ff75">rfbMarkRectAsModified</a>(screen,x1,y1,x2,y2).</div></div><!-- fragment --><p> This tells LibVNCServer to send updates to all connected clients.</p>
<p>There exist the following IO functions as members of rfbScreen: <a class="el" href="structrfb_screen_info.html#a51b0c505ba66266f87343c8f69dbab9d">rfbScreenInfo::kbdAddEvent()</a>, <a class="el" href="structrfb_screen_info.html#a0f33e037a67ec3eee99f51ed0af06242">rfbScreenInfo::kbdReleaseAllKeys()</a>, <a class="el" href="structrfb_screen_info.html#a1b6c83cc13ee3ba6ff97ce558daeabf9">rfbScreenInfo::ptrAddEvent()</a> and <a class="el" href="structrfb_screen_info.html#a9ac3fc9f35b7b610e9b3e86a15028f9f">rfbScreenInfo::setXCutText()</a></p>
<p><a class="el" href="structrfb_screen_info.html#a51b0c505ba66266f87343c8f69dbab9d">rfbScreenInfo::kbdAddEvent()</a> is called when a key is pressed. <a class="el" href="structrfb_screen_info.html#a0f33e037a67ec3eee99f51ed0af06242">rfbScreenInfo::kbdReleaseAllKeys()</a> is not called at all (maybe in the future). <a class="el" href="structrfb_screen_info.html#a1b6c83cc13ee3ba6ff97ce558daeabf9">rfbScreenInfo::ptrAddEvent()</a> is called when the mouse moves or a button is pressed. WARNING: if you want to have proper cursor handling, call <a class="el" href="group__libvncserver__api.html#ga6b2065e71b8c8780c383a09c9fbaf63d" title="cursor handling for the pointer ">rfbDefaultPtrAddEvent()</a> in your own function. This sets the coordinates of the cursor. <a class="el" href="structrfb_screen_info.html#a9ac3fc9f35b7b610e9b3e86a15028f9f">rfbScreenInfo::setXCutText()</a> is called when the selection changes.</p>
<p>There are only two hooks: <a class="el" href="structrfb_screen_info.html#aeb36d7202d67dfcb38db326f620c6718" title="newClientHook is called just after a new client is created ">rfbScreenInfo::newClientHook()</a> is called when a new client has connected. <a class="el" href="structrfb_screen_info.html#a7b325e9e85da44e699ac1a7ee8f1a8ee" title="displayHook is called just before a frame buffer update ">rfbScreenInfo::displayHook()</a> is called just before a frame buffer update is sent.</p>
<p>You can also override the following methods: <a class="el" href="structrfb_screen_info.html#a2698ecd42f7381afb1622817b7f600c6">rfbScreenInfo::getCursorPtr()</a> This could be used to make an animated cursor (if you really want ...) <a class="el" href="structrfb_screen_info.html#a935e30b1ff3362b61d9fe1b6c8283541">rfbScreenInfo::setTranslateFunction()</a> If you insist on colour maps or something more obscure, you have to implement this. Default is a trueColour mapping.</p>
<h1><a class="anchor" id="cursor_handling"></a>
Cursor handling</h1>
<p>The screen holds a pointer <a class="el" href="structrfb_screen_info.html#a81c9e996f31d116f15a1ce20ecb0be15">rfbScreenInfo::cursor</a> to the current cursor. Whenever you set it, remember that any dynamically created cursor (like return value from <a class="el" href="group__libvncserver__api.html#gadd4c3d7a0ff22fa24815a9456b49942e">rfbMakeXCursor()</a>) is not free'd!</p>
<p>The <a class="el" href="structrfb_cursor.html">rfbCursor</a> structure consists mainly of a mask and a source. The <a class="el" href="structrfb_cursor.html#a73224b9ec68e6e658c4b1c86872fa1ce" title="points to bits ">rfbCursor::mask</a> describes, which pixels are drawn for the cursor (a cursor needn't be rectangular). The <a class="el" href="structrfb_cursor.html#ac7ce35c0391b2da852a31274736a6ad2" title="points to bits ">rfbCursor::source</a> describes, which colour those pixels should have.</p>
<p>The standard is an XCursor: a cursor with a foreground and a background colour (stored in backRed,backGreen,backBlue and the same for foreground in a range from 0-0xffff). Therefore, the arrays "mask" and "source" contain pixels as single bits stored in bytes in MSB order. The rows are padded, such that each row begins with a new byte (i.e. a 10x4 cursor's mask has 2x4 bytes, because 2 bytes are needed to hold 10 bits).</p>
<p>It is however very easy to make a cursor like this: </p><div class="fragment"><div class="line"><span class="keywordtype">char</span>* cur=<span class="stringliteral">&quot;    &quot;</span></div><div class="line">          <span class="stringliteral">&quot; xx &quot;</span></div><div class="line">          <span class="stringliteral">&quot; x  &quot;</span></div><div class="line">          <span class="stringliteral">&quot;    &quot;</span>;</div><div class="line"><span class="keywordtype">char</span>* <a class="code" href="_s_d_lvncviewer_8c.html#aa2e5f6d39f117d3c3104468e9661618c">mask</a>=<span class="stringliteral">&quot;xxxx&quot;</span></div><div class="line">           <span class="stringliteral">&quot;xxxx&quot;</span></div><div class="line">           <span class="stringliteral">&quot;xxxx&quot;</span></div><div class="line">           <span class="stringliteral">&quot;xxx &quot;</span>;</div><div class="line">rfbCursorPtr c=<a class="code" href="group__libvncserver__api.html#gadd4c3d7a0ff22fa24815a9456b49942e">rfbMakeXCursor</a>(4,4,cur,mask);</div></div><!-- fragment --><p> You can even set <a class="el" href="structrfb_cursor.html#a73224b9ec68e6e658c4b1c86872fa1ce" title="points to bits ">rfbCursor::mask</a> to NULL in this call and LibVNCServer will calculate a mask for you (dynamically, so you have to free it yourself).</p>
<p>There is also an array named <a class="el" href="structrfb_cursor.html#af59ff96c2cd9ecb7760f00f542e41761" title="source bytes for a rich cursor ">rfbCursor::richSource</a> for colourful cursors. They have the same format as the frameBuffer (i.e. if the server is 32 bit, a 10x4 cursor has 4x10x4 bytes).</p>
<h1><a class="anchor" id="screen_client_difference"></a>
What is the difference between rfbScreenInfoPtr and rfbClientPtr?</h1>
<p>The rfbScreenInfoPtr is a pointer to a <a class="el" href="structrfb_screen_info.html" title="Per-screen (framebuffer) structure. ">rfbScreenInfo</a> structure, which holds information about the server, like pixel format, io functions, frame buffer etc. The rfbClientPtr is a pointer to an <a class="el" href="structrfb_client_rec.html">rfbClientRec</a> structure, which holds information about a client, like pixel format, socket of the connection, etc. A server can have several clients, but needn't have any. So, if you have a server and three clients are connected, you have one instance of a <a class="el" href="structrfb_screen_info.html" title="Per-screen (framebuffer) structure. ">rfbScreenInfo</a> and three instances of <a class="el" href="structrfb_client_rec.html">rfbClientRec</a>'s.</p>
<p>The <a class="el" href="structrfb_client_rec.html">rfbClientRec</a> structure holds a member <a class="el" href="structrfb_client_rec.html#aec81ceb5c74e15a16fed99696da53ced" title="back pointer to the screen ">rfbClientRec::screen</a> which points to the server. So, to access the server from the client structure, you use client-&gt;screen.</p>
<p>To access all clients from a server be sure to use the provided iterator <a class="el" href="group__libvncserver__api.html#ga0e6ec0764fcf459b5f4e191eabc02469">rfbGetClientIterator()</a> with <a class="el" href="group__libvncserver__api.html#gaa14312283c0782436cffcd7fb601f919">rfbClientIteratorNext()</a> and <a class="el" href="group__libvncserver__api.html#ga5324c767981d736ca9c48a91cf65d3b2">rfbReleaseClientIterator()</a> to prevent thread clashes.</p>
<h1><a class="anchor" id="example_code"></a>
Example Code</h1>
<p>There are two documented examples included:</p><ul>
<li><a class="el" href="example_8c.html">example.c</a>, a shared scribble sheet</li>
<li><a class="el" href="pnmshow_8c.html">pnmshow.c</a>, a program to show PNMs (pictures) over the net.</li>
</ul>
<p>The examples are not too well documented, but easy straight forward and a good starting point.</p>
<p>Try <a class="el" href="example_8c.html">example.c</a>: it outputs on which port it listens (default: 5900), so it is display 0. To view, call</p><div class="fragment"><div class="line">vncviewer :0 </div></div><!-- fragment --><p> You should see a sheet with a gradient and "Hello World!" written on it. Try to paint something. Note that every time you click, there is some bigger blot, whereas when you drag the mouse while clicked you draw a line. The size of the blot depends on the mouse button you click. Open a second vncviewer with the same parameters and watch it as you paint in the other window. This also works over internet. You just have to know either the name or the IP of your machine. Then it is</p><div class="fragment"><div class="line">vncviewer machine.where.example.runs.com:0 </div></div><!-- fragment --><p> or similar for the remote client. Now you are ready to type something. Be sure that your mouse sits still, because every time the mouse moves, the cursor is reset to the position of the pointer! If you are done with that demo, press the down or up arrows. If your viewer supports it, then the dimensions of the sheet change. Just press Escape in the viewer. Note that the server still runs, even if you closed both windows. When you reconnect now, everything you painted and wrote is still there. You can press "Page Up" for a blank page.</p>
<p>The demo <a class="el" href="pnmshow_8c.html">pnmshow.c</a> is much simpler: you either provide a filename as argument or pipe a file through stdin. Note that the file has to be a raw pnm/ppm file, i.e. a truecolour graphics. Only the Escape key is implemented. This may be the best starting point if you want to learn how to use LibVNCServer. You are confronted with the fact that the bytes per pixel can only be 8, 16 or 32. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jun 13 2020 13:15:43 for LibVNCServer/LibVNCClient by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
